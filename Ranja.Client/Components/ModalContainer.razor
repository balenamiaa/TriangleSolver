@using Ranja.Client.Services
@inject IModalService ModalService
@inject IJSRuntime JSRuntime
@implements IDisposable

@* Modal Container - acts like React's createPortal *@
@foreach (var modal in ModalService.GetActiveModals())
{
    <div class="modal-overlay"
         style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: @(modal.Options.ZIndex + GetModalIndex(modal)); pointer-events: auto; background-color: rgba(0, 0, 0, 0.5);"
         @onclick="@(() => OnBackdropClick(modal))"
         @onkeydown="@((e) => OnKeyDown(e, modal))">

        @if (modal.Id == "value-popup")
        {
            <ValuePopupContent Modal="modal" OnClose="@(() => CloseModal(modal.Id))"/>
        }
        @* Add other modal types here as needed *@
    </div>
}

@code {

    protected override void OnInitialized()
    {
        ModalService.OnModalStateChanged += StateHasChanged;
    }

    public void Dispose()
    {
        ModalService.OnModalStateChanged -= StateHasChanged;
    }

    private int GetModalIndex(ModalInfo modal)
    {
        var modals = ModalService.GetActiveModals().ToList();
        return modals.IndexOf(modal);
    }

    private async Task OnBackdropClick(ModalInfo modal)
    {
        if (modal.Options.CloseOnBackdropClick)
        {
            await ModalService.HideModalAsync(modal.Id);
        }
    }

    private async Task OnKeyDown(KeyboardEventArgs e, ModalInfo modal)
    {
        if (e.Key == "Escape" && modal.Options.CloseOnEscape)
        {
            await ModalService.HideModalAsync(modal.Id);
        }
    }

    private async Task CloseModal(string modalId)
    {
        await ModalService.HideModalAsync(modalId);
    }

} 
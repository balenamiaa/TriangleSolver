@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using Ranja.Client.Models
@using Ranja.Solver
@inject IJSRuntime JSRuntime

<div class="triangle-container relative" @ref="containerElement">
    <svg viewBox="0 0 @Configuration.SvgViewBox.Width @Configuration.SvgViewBox.Height"
         class="w-full h-full border border-gray-300 rounded-lg bg-white">

        <!-- Lines -->
        @foreach (var line in Configuration.Lines)
        {
            var p1 = GetSvgPoint(line.Segment.P1.Content);
            var p2 = GetSvgPoint(line.Segment.P2.Content);

            @if (p1 != null && p2 != null)
            {
                <line x1="@p1.Value.X" y1="@p1.Value.Y" x2="@p2.Value.X" y2="@p2.Value.Y"
                      stroke="#4b5563" stroke-width="2" />

                <!-- Segment value display -->
                @if (SegmentValues.TryGetValue(line.Segment, out var segmentValueInfo))
                {
                    var midX = (p1.Value.X + p2.Value.X) / 2;
                    var midY = (p1.Value.Y + p2.Value.Y) / 2;
                    var displayText = segmentValueInfo.IsInconsistent ? "??" : segmentValueInfo.DisplayValue.ToString("F1");
                    var textColor = segmentValueInfo.IsInconsistent ? "#dc2626" : "#1e3a8a";
                    var segmentId = FormatSegmentId(line.Segment);
                    
                    <text>
                        <text x="@midX" y="@(midY - 6)" font-size="10" fill="@textColor" text-anchor="middle" dominant-baseline="auto"
                            style="cursor: pointer" @onclick="@(() => OnValueClickInternal(segmentId, midX, midY - 6))"
                            @onclick:stopPropagation="true">
                            @displayText
                        </text>
                    </text>
                }
            }
        }

        <!-- Points -->
        @foreach (var pointPair in Configuration.Points)
        {
            var pointName = pointPair.Key;
            var svgPoint = GetSvgPoint(pointName);

            @if (svgPoint != null)
            {
                <circle cx="@svgPoint.Value.X" cy="@svgPoint.Value.Y" r="4" fill="#1e40af" />

                var labelPos = GetPointLabelPosition(svgPoint.Value, pointPair.Value);

                <text>
                    <text x="@labelPos.X" y="@labelPos.Y" font-size="18" font-weight="bold" fill="rgb(255,114,128)"
                        text-anchor="middle" dominant-baseline="central">
                        @pointName
                    </text>
                </text>
            }
        }

        <!-- Angles -->
        @foreach (var angle in Configuration.Angles)
        {
            var p1 = GetSvgPoint(angle.Angle.P1.Content);
            var vertex = GetSvgPoint(angle.Angle.Vertex.Content);
            var p2 = GetSvgPoint(angle.Angle.P2.Content);

            @if (p1 != null && vertex != null && p2 != null)
            {
                <!-- Angle arc -->
                var arcPath = GeometryUtils.CalculateAngleArc(p1.Value, vertex.Value, p2.Value, angle.Radius);
                <path d="@arcPath" fill="none" stroke="@angle.Color" stroke-width="1.2" />

                <!-- Angle label -->
                var labelPos = GeometryUtils.CalculateAngleLabelPosition(p1.Value, vertex.Value, p2.Value, angle.Radius,
                angle.TextOffsetScale);
                var displayValue = GetAngleDisplayValue(angle);
                var angleColor = GetAngleColor(angle);
                var angleId = FormatAngleId(angle.Angle);

                <text>
                    <text x="@labelPos.X" y="@labelPos.Y" font-size="@(IsVariableAngle(angle.Angle) ? "14" : "12")"
                        font-style="@(IsVariableAngle(angle.Angle) ? "italic" : "normal")" font-weight="@angle.FontWeight"
                        fill="@angleColor" text-anchor="middle" dominant-baseline="central" style="cursor: pointer"
                        @onclick="@(() => OnValueClickInternal(angleId, labelPos.X, labelPos.Y))"
                        @onclick:stopPropagation="true">
                        @displayValue
                    </text>
                </text>
            }
        }
    </svg>
</div>

@code {
    [Parameter] public TriangleConfiguration Configuration { get; set; } = null!;
    [Parameter] public double XValue { get; set; } = 30.0;
    [Parameter] public Dictionary<Angle, ValueInfo> AngleValues { get; set; } = new();
    [Parameter] public Dictionary<Segment, ValueInfo> SegmentValues { get; set; } = new();
    [Parameter] public EventCallback<(string ValueId, double X, double Y)> OnValueClick { get; set; }

    private ElementReference containerElement;
    private Dictionary<string, Vector2D> _svgPoints = new();

    protected override void OnParametersSet()
    {
        CalculateSvgPoints();
    }

    private void CalculateSvgPoints()
    {
        _svgPoints.Clear();

        foreach (var pointPair in Configuration.Points)
        {
            var svgPoint = GeometryUtils.TransformPoint(
            pointPair.Value.LogicalCoords,
            Configuration.LogicalCoords,
            Configuration.SvgViewBox);
            _svgPoints[pointPair.Key] = svgPoint;
        }

        // Calculate point D as intersection of lines BE and CF
        if (_svgPoints.ContainsKey("B") && _svgPoints.ContainsKey("E") &&
        _svgPoints.ContainsKey("C") && _svgPoints.ContainsKey("F"))
        {
            // Need to work in logical coordinates for intersection, then transform
            var bLogical = Configuration.Points["B"].LogicalCoords;
            var eLogical = Configuration.Points["E"].LogicalCoords;
            var cLogical = Configuration.Points["C"].LogicalCoords;
            var fLogical = Configuration.Points["F"].LogicalCoords;

            var line1 = new LineSegment(bLogical, eLogical);
            var line2 = new LineSegment(cLogical, fLogical);

            var intersection = GeometryUtils.LineIntersection(line1, line2);
            if (intersection.HasValue)
            {
                var dSvg = GeometryUtils.TransformPoint(intersection.Value, Configuration.LogicalCoords, Configuration.SvgViewBox);
                _svgPoints["D"] = dSvg;
            }
        }
    }

    private Vector2D? GetSvgPoint(string pointName)
    {
        return _svgPoints.TryGetValue(pointName, out var point) ? point : null;
    }

    private string FormatAngleId(Angle angle)
    {
        return $"{angle.P1.Content}{angle.Vertex.Content}{angle.P2.Content}";
    }

    private string FormatSegmentId(Segment segment)
    {
        var p1 = segment.P1.Content;
        var p2 = segment.P2.Content;
        return string.Compare(p1, p2) < 0 ? $"{p1}{p2}" : $"{p2}{p1}";
    }

    private bool IsVariableAngle(Angle angle)
    {
        // Check if this is the variable angle FEB (our x)
        var febAngle = Angle.FromString("FEB");
        return angle.Equals(febAngle);
    }

    private string GetAngleDisplayValue(AngleDefinition angle)
    {
        if (IsVariableAngle(angle.Angle)) // This is our variable x
        {
            return $"{XValue:F1}°";
        }

        if (AngleValues.TryGetValue(angle.Angle, out var solvedValueInfo))
        {
            if (solvedValueInfo.IsInconsistent)
            {
                return "??°";
            }
            return $"{solvedValueInfo.DisplayValue:F0}°";
        }

        return angle.DisplayValue;
    }

    private string GetAngleColor(AngleDefinition angle)
    {
        if (IsVariableAngle(angle.Angle)) // This is our variable x
        {
            return angle.Color; // Keep the original color for the variable
        }

        if (AngleValues.TryGetValue(angle.Angle, out var solvedValueInfo))
        {
            if (solvedValueInfo.IsInconsistent)
            {
                return "#dc2626"; // Red color for inconsistent angles
            }
        }

        return angle.Color; // Default color from angle definition
    }

    private Vector2D GetPointLabelPosition(Vector2D svgPoint, PointDefinition pointDef)
    {
        var offset = 12.0;

        return pointDef.LabelPosition switch
        {
            LabelPosition.VerticalAbove => new Vector2D(svgPoint.X, svgPoint.Y - offset),
            LabelPosition.VerticalBelow => new Vector2D(svgPoint.X, svgPoint.Y + offset),
            LabelPosition.HorizontalRight => new Vector2D(svgPoint.X + offset, svgPoint.Y),
            LabelPosition.HorizontalLeft => new Vector2D(svgPoint.X - offset, svgPoint.Y),
            _ => new Vector2D(svgPoint.X, svgPoint.Y - offset)
        };
    }

    private async Task OnValueClickInternal(string valueId, double svgX, double svgY)
    {
        // Convert SVG coordinates to screen coordinates
        var bounds = await JSRuntime.InvokeAsync<BoundingClientRect>("getBoundingClientRect", containerElement);

        // Calculate the scale factor of the SVG
        var scaleX = bounds.Width / Configuration.SvgViewBox.Width;
        var scaleY = bounds.Height / Configuration.SvgViewBox.Height;

        // Convert SVG coordinates to relative position within the SVG element
        var relativeX = svgX * scaleX;
        var relativeY = svgY * scaleY;

        // Convert to screen coordinates
        var screenX = bounds.Left + relativeX;
        var screenY = bounds.Top + relativeY;

        await OnValueClick.InvokeAsync((valueId, screenX, screenY));
    }

    public async Task UpdateVisualization()
    {
        CalculateSvgPoints();
        StateHasChanged();
        await Task.CompletedTask;
    }

    public record BoundingClientRect(double Left, double Top, double Width, double Height);
}
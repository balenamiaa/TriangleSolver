@using Microsoft.AspNetCore.Components.Web
@implements IDisposable

<div class="angle-slider-container">
    <label class="block text-sm font-medium text-gray-700 mb-2">@Label</label>

    <div class="relative py-4">
        <div class="slider-track relative h-3 bg-gray-200 rounded-full shadow-inner">
            <div class="slider-progress h-3 bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-600 rounded-full transition-all duration-75 ease-out shadow-sm"
                 style="width: @(((Value - Min) / (Max - Min)) * 100)%"></div>

            <div class="absolute inset-0 pointer-events-none">
                @foreach (var tick in AngleTicks)
                {
                    var position = ((tick.Value - Min) / (Max - Min)) * 100;
                    <div class="absolute top-0 left-0 w-full h-full">
                        <div class="absolute top-0" style="left: @(position)%">
                            <div class="w-0.5 h-8 bg-gray-400 -mt-2.5 rounded-full"></div>
                            <div class="text-xs text-gray-600 mt-2 text-center font-medium whitespace-nowrap">
                                @(tick.Value)°
                            </div>
                        </div>
                    </div>
                }
            </div>
        </div>

        <input type="range"
               value="@Value"
               @oninput="OnSliderInput"
               min="@Min"
               max="@Max"
               step="0.1"
               class="slider-input absolute top-4 w-full h-3 opacity-0 cursor-pointer"/>

        <div class="slider-thumb absolute top-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none z-10"
             style="left: @(((Value - Min) / (Max - Min)) * 100)%">
            <div class="relative">
                <div class="w-7 h-7 bg-white border-3 border-blue-500 rounded-full shadow-lg transition-all duration-200 ring-2 ring-blue-200 ring-opacity-50">
                    <div class="w-2 h-2 bg-blue-500 rounded-full absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"></div>
                </div>
                
                <div class="absolute -top-12 left-1/2 transform -translate-x-1/2">
                    <div class="bg-gray-800 text-white px-3 py-1.5 rounded-lg text-sm font-medium whitespace-nowrap shadow-lg">
                        @Value.ToString("F1")°
                        <div class="absolute top-full left-1/2 transform -translate-x-1/2">
                            <div class="w-2 h-2 bg-gray-800 transform rotate-45"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .angle-slider-container { @@apply w-full; }
    .slider-input::-webkit-slider-thumb { @@apply appearance-none w-7 h-7 cursor-pointer; }
    .slider-input::-moz-range-thumb { @@apply appearance-none w-7 h-7 cursor-pointer border-0 bg-transparent; }
    .slider-input:focus { outline: none; }
    .slider-input:focus + .slider-thumb .w-7 { @@apply ring-4 ring-blue-400 ring-opacity-60; }
    .slider-input:hover + .slider-thumb .w-7 { @@apply scale-110 ring-4 ring-blue-300 ring-opacity-40; }
</style>

@code {
    [Parameter] public double Value { get; set; } = 30.0;
    [Parameter] public EventCallback<double> ValueChanged { get; set; }
    [Parameter] public EventCallback<double> OnValueChanged { get; set; }
    [Parameter] public double Min { get; set; } = 0;
    [Parameter] public double Max { get; set; } = 120;
    [Parameter] public string Label { get; set; } = "Angle";

    private readonly List<(double Value, string Label)> AngleTicks = [(0, "0"), (30, "30"), (45, "45"), (60, "60"), (90, "90"), (120, "120")];
    private Timer? throttleTimer;
    private double pendingValue;
    private bool hasPendingValue = false;

    private async Task OnSliderInput(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var newValue))
        {
            Value = newValue;
            await ValueChanged.InvokeAsync(Value);
            StateHasChanged();
            
            if (OnValueChanged.HasDelegate)
            {
                pendingValue = newValue;
                hasPendingValue = true;
                
                throttleTimer?.Dispose();
                throttleTimer = new Timer(async _ =>
                {
                    if (hasPendingValue)
                    {
                        var valueToProcess = pendingValue;
                        hasPendingValue = false;
                        await InvokeAsync(async () => await OnValueChanged.InvokeAsync(valueToProcess));
                    }
                }, null, TimeSpan.FromMilliseconds(50), Timeout.InfiniteTimeSpan);
            }
        }
    }

    public void Dispose() => throttleTimer?.Dispose();
} 
@page "/"
@using Ranja.Client.Services
@using Ranja.Client.Models
@using Ranja.Solver
@using System.Diagnostics
@inject IJSRuntime JSRuntime
@inject IModalService ModalService
@implements IDisposable

<PageTitle>Triangle Solver - The Hardest Easy Problem</PageTitle>

<div class="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 p-4">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">Triangle Solver</h1>
            <p class="text-gray-600">The Hardest Easy Problem - Interactive Geometry</p>
        </div>

        <!-- Main Content -->
        <div class="grid grid-cols-1 xl:grid-cols-3 gap-8">
            <!-- Triangle Visualization -->
            <div class="xl:col-span-2">
                <div class="bg-white rounded-2xl shadow-xl p-6">
                    <h2 class="text-2xl font-semibold text-gray-800 mb-4">Triangle Visualization</h2>

                    <!-- Angle X Slider -->
                    <div class="mb-6">
                        <AngleSlider @bind-Value="AngleX" Min="0" Max="120" Label="Angle x (∠FEB)"
                                     OnValueChanged="OnAngleChanged"/>
                    </div>

                    <!-- Triangle Container -->
                    <div class="relative bg-gray-50 rounded-xl p-8 min-h-[600px]" @onclick="() => CloseAllPopups()">
                        <TriangleRenderer @ref="triangleRenderer" Configuration="triangleConfig" XValue="angleX"
                                          AngleValues="currentAngleValues" SegmentValues="currentSegmentValues"
                                          OnValueClick="@((args) => ShowValuePopup(args.ValueId, args.X, args.Y))"/>
                    </div>
                </div>
            </div>

            <!-- Values Panel -->
            <div class="space-y-6">
                <!-- Computed Values -->
                <div class="bg-white rounded-2xl shadow-xl p-6">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Computed Values</h3>
                    <ValuesDisplay AngleValues="currentAngleValues" SegmentValues="currentSegmentValues"
                                   OnValueClick="@((args) => ShowValuePopup(args.ValueId, args.X, args.Y))"/>
                </div>

                <!-- Solver Status -->
                <div class="bg-white rounded-2xl shadow-xl p-6">
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">Solver Status</h3>
                    <SolverStatus Result="solverResult" Inconsistencies="inconsistencies"
                                  IterationCount="iterationCount"/>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private TriangleRenderer? triangleRenderer;

    private double angleX = 30.0;
    private TriangleConfiguration triangleConfig = default!;

    // Hold multiple values per angle/segment - now using Angle and Segment as keys
    private Dictionary<Angle, ValueInfo> currentAngleValues = new();
    private Dictionary<Segment, ValueInfo> currentSegmentValues = new();
    private List<string> inconsistencies = [];

    private Solver.SolveResult solverResult;
    private int iterationCount;
    private Timer? debounceTimer;
    private bool isComputing = false;
    private double lastComputedAngle = -1;

    public double AngleX
    {
        get => angleX;
        set
        {
            if (Math.Abs(angleX - value) > 0.01)
            {
                angleX = value;
                StateHasChanged();
            }
        }
    }

    protected override void OnInitialized()
    {
        InitializeTriangleConfiguration();
        SolveTriangle();
    }

    private void InitializeTriangleConfiguration()
    {
        triangleConfig = new TriangleConfiguration
        {
            LogicalCoords = new LogicalCoordinates(-80, 80, -48, 48),
            SvgViewBox = new SvgViewBox(600, 400),

            Points = new Dictionary<string, PointDefinition>
            {
                ["A"] = new(new Vector2D(71.8, 0), LabelPosition.VerticalAbove, "12"),
                ["B"] = new(new Vector2D(-70, 25), LabelPosition.VerticalAbove, "12"),
                ["C"] = new(new Vector2D(-70, -25), LabelPosition.VerticalBelow, "12"),
                ["E"] = new(new Vector2D(-3.7, -13.3), LabelPosition.VerticalBelow, "12"),
                ["F"] = new(new Vector2D(-20.8, 16.3), LabelPosition.VerticalAbove, "12")
                // D will be calculated as intersection
            },

            Lines =
            [
                new(Segment.FromString("AF")), new(Segment.FromString("FB")), new(Segment.FromString("BC")),
                new(Segment.FromString("CE")), new(Segment.FromString("EA")), new(Segment.FromString("EF")),
                new(Segment.FromString("ED")), new(Segment.FromString("DC")), new(Segment.FromString("DF")), new(Segment.FromString("DB")),
            ],

            Angles =
            [
                new AngleDefinition(Angle.FromString("CBE"), "60°", 16, 1.5),
                new AngleDefinition(Angle.FromString("EBA"), "20°", 36, 1.5),
                new AngleDefinition(Angle.FromString("BCF"), "50°", 18, 1.6),
                new AngleDefinition(Angle.FromString("FCA"), "30°", 18, 1.6),
                new AngleDefinition(Angle.FromString("FEB"), "x", 24, 1.5, "#b91c1c", "bold"),
// Additional angles from solver - expanded list
                new AngleDefinition(Angle.FromString("CEB"), "", 24, 1.5),
                new AngleDefinition(Angle.FromString("AEF"), "", 24, 1.5),
                new AngleDefinition(Angle.FromString("BDC"), "", 12, 1.95),
                new AngleDefinition(Angle.FromString("FDE"), "", 12, 1.95),
                new AngleDefinition(Angle.FromString("BDF"), "", 12, 1.95),
                new AngleDefinition(Angle.FromString("CDE"), "", 12, 1.95),
                new AngleDefinition(Angle.FromString("BFD"), "", 16, 1.75),
                new AngleDefinition(Angle.FromString("AFE"), "", 16, 1.75), 
                new AngleDefinition(Angle.FromString("EFC"), "", 16, 1.5),
                new AngleDefinition(Angle.FromString("CAB"), "", 24, 1.5),
            ]
        };
    }

    private async Task OnAngleChanged(double newValue)
    {
        if (isComputing) return;

        AngleX = newValue;

        // Debounce the computation
        debounceTimer?.Dispose();
        debounceTimer = new Timer(async _ =>
        {
            await InvokeAsync(() =>
            {
                SolveTriangle();
                StateHasChanged();
                if (triangleRenderer != null)
                    _ = triangleRenderer.UpdateVisualization();
            });
        }, null, TimeSpan.FromMilliseconds(300), Timeout.InfiniteTimeSpan);

        await Task.CompletedTask;
    }

    private void SolveTriangle()
    {
        if (isComputing || Math.Abs(angleX - lastComputedAngle) < 0.01) return;

        isComputing = true;
        lastComputedAngle = angleX;

        try
        {
            var solver = new Ranja.Solver.Solver() { Rules = Problem1Rules.Rules };

            solver.AddGivenAngleValue(Ranja.Solver.Angle.FromString("DBA"), 20);
            solver.AddGivenAngleValue(Ranja.Solver.Angle.FromString("CBD"), 60);
            solver.AddGivenAngleValue(Ranja.Solver.Angle.FromString("ACD"), 30);
            solver.AddGivenAngleValue(Ranja.Solver.Angle.FromString("DCB"), 50);
            solver.AddGivenAngleValue(Ranja.Solver.Angle.FromString("FED"), angleX);
            solver.AddGivenSegmentValue(Ranja.Solver.Segment.FromString("BC"), 1.0);

            solverResult = solver.Solve();
            iterationCount = 0;

            for (int i = 0; i < Ranja.Solver.Constants.MAX_ITERATIONS; i++)
            {
                iterationCount = i;
                if (solverResult != Ranja.Solver.Solver.SolveResult.MaxIterationsReached) break;
            }

            currentAngleValues.Clear();
            currentSegmentValues.Clear();
            inconsistencies.Clear();

            // Process angles - collect all values with their reasons
            foreach (var kvp in solver.AngleStorage.AngleValues)
            {
                var angle = kvp.Key;
                var values = kvp.Value;

                var distinctValues = solver.GetDistinctAngleValues(angle).ToList();
                var allValueDetails = new List<ValueDetail>();
                var hasInconsistencies = false;

                foreach (var value in values)
                {
                    string reason = value switch
                    {
                        GivenAngleValue gav => $"Given: {gav.Value:F1}°",
                        ComputedAngleValue cav => cav.Reason,
                        InconsistencyAngleValue iav => $"Inconsistency: {iav.Description}",
                        _ => "Unknown source"
                    };

                    double numericValue = value switch
                    {
                        GivenAngleValue gav => gav.Value,
                        ComputedAngleValue cav => cav.Value,
                        InconsistencyAngleValue => double.NaN,
                        _ => double.NaN
                    };

                    if (!double.IsNaN(numericValue))
                    {
                        allValueDetails.Add(new ValueDetail(numericValue, reason));
                    }
                    else if (value is InconsistencyAngleValue)
                    {
                        // Include inconsistency details even though numeric value is NaN
                        allValueDetails.Add(new ValueDetail(double.NaN, reason));
                        hasInconsistencies = true;
                    }
                }

                if (allValueDetails.Any())
                {
                    var isInconsistent = distinctValues.Count > 1 || hasInconsistencies;
                    currentAngleValues[angle] = new ValueInfo(distinctValues, allValueDetails, isInconsistent);
                }
            }

            // Process segments - collect all values with their reasons
            foreach (var kvp in solver.SegmentStorage.SegmentValues)
            {
                var segment = kvp.Key;
                var values = kvp.Value;

                var distinctValues = solver.GetDistinctSegmentValues(segment).ToList();
                var allValueDetails = new List<ValueDetail>();
                var hasInconsistencies = false;

                foreach (var value in values)
                {
                    string reason = value switch
                    {
                        GivenSegmentValue gsv => $"Given: {gsv.Value:F2}",
                        ComputedSegmentValue csv => csv.Reason,
                        InconsistencySegmentValue isv => $"Inconsistency: {isv.Description}",
                        _ => "Unknown source"
                    };

                    double numericValue = value switch
                    {
                        GivenSegmentValue gsv => gsv.Value,
                        ComputedSegmentValue csv => csv.Value,
                        InconsistencySegmentValue => double.NaN,
                        _ => double.NaN
                    };

                    if (!double.IsNaN(numericValue))
                    {
                        allValueDetails.Add(new ValueDetail(numericValue, reason));
                    }
                    else if (value is InconsistencySegmentValue)
                    {
                        // Include inconsistency details even though numeric value is NaN
                        allValueDetails.Add(new ValueDetail(double.NaN, reason));
                        hasInconsistencies = true;
                    }
                }

                if (allValueDetails.Any())
                {
                    var isInconsistent = distinctValues.Count > 1 || hasInconsistencies;
                    currentSegmentValues[segment] = new ValueInfo(distinctValues, allValueDetails, isInconsistent);
                }
            }

            inconsistencies.AddRange(solver.Inconsistencies);
        }
        finally
        {
            isComputing = false;
            StateHasChanged();
        }
    }



    private async Task ShowValuePopup(string valueId, double x, double y)
    {
        ValueInfo? valueInfo = null;
        bool isAngle = true;

        // Try to find the value by converting the string ID to Angle/Segment
        if (valueId.Length == 3) // Angle
        {
            var angle = Angle.FromString(valueId);
            if (currentAngleValues.TryGetValue(angle, out var angleValue))
            {
                valueInfo = angleValue;
                isAngle = true;
            }
        }
        else if (valueId.Length == 2) // Segment
        {
            var segment = Segment.FromString(valueId);
            if (currentSegmentValues.TryGetValue(segment, out var segmentValue))
            {
                valueInfo = segmentValue;
                isAngle = false;
            }
        }

        if (valueInfo != null)
        {
            var valueData = new ValuePopupData(
                Id: valueId,
                Values: valueInfo.AllValues,
                AllValueDetails: valueInfo.AllValueDetails,
                IsInconsistent: valueInfo.IsInconsistent,
                IsAngle: isAngle
            );

            var options = new ModalOptions(
                X: x,
                Y: y,
                CloseOnBackdropClick: true,
                CloseOnEscape: true,
                ZIndex: 1000
            );

            await ModalService.ShowModalAsync("value-popup", valueData, options);
        }
    }

    private async Task CloseAllPopups()
    {
        await ModalService.HideAllModalsAsync();
    }

    public void Dispose()
    {
        debounceTimer?.Dispose();
    }

}
